import express, { Request, Response, NextFunction, Router } from "express";
import { AppDataSource } from "../data-source";
import { User, UserRole } from "../entity/User";
import { Subscription } from "../entity/Subscription";
import { Package } from "../entity/Package";
import mysql from "mysql2/promise";
import { generatePassword } from "../utils/password";
import nodemailer from "nodemailer";
import dotenv from "dotenv";
import bcrypt from "bcrypt";  // bcrypt import√°l√°sa
import { isAdmin } from "../utils/isAdmin";
const jwt = require('jsonwebtoken');
dotenv.config();
import ejs from "ejs";

const router = Router();

const db = mysql.createPool({
  host: "localhost",
  user: "root",
  password: "",
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});

// SMTP be√°ll√≠t√°sok
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: Number(process.env.SMTP_PORT),
  secure: true,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});
function generateToken(user: any) {
  return jwt.sign({ id: user.id, email: user.email }, process.env.JWT_SECRET, { expiresIn: '1d' });
}

function tokencheck(req: any, res: any, next: NextFunction) {
  const authHeader = req.header('Authorization');
  if (!authHeader) {
    return res.status(400).send('Jelentkezz be!');
  }

  const token = authHeader.split(' ')[1]; // A Bearer token kinyer√©se
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log(decoded); // Dek√≥dolt token ki√≠rat√°sa
    req.user = decoded;  // A dek√≥dolt tokenet hozz√°rendeled a req.user-hez
    next(); // Ha √©rv√©nyes a token, megy tov√°bb
  } catch (error) {
    return res.status(400).send('Hib√°s vagy lej√°rt token!');
  }
}

// üìå Jelsz√≥ √©rv√©nyes√≠t√©si szab√°lyok
function validatePassword(password: string): boolean {
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z\d]{8,}$/;
  return passwordRegex.test(password);
}

// üìå Regisztr√°ci√≥
router.post("/register", async (req: any, res: any) => {
  try {
    const { username, email, password } = req.body;

    if (!username || !email || !password) {
      return res.status(400).json({ message: "Hi√°nyz√≥ adatok! (username, email, password sz√ºks√©ges)" });
    }

    if (!validatePassword(password)) {
      return res.status(400).json({ message: "A jelsz√≥ nem felel meg az er≈ëss√©gi k√∂vetelm√©nyeknek!" });
    }

    const existingUser = await AppDataSource.getRepository(User).findOne({ where: { email } });
    if (existingUser) {
      return res.status(400).json({ message: "Ez az e-mail m√°r l√©tezik!" });
    }

    // Jelsz√≥ hash-el√©se bcrypt-tel
    const hashedPassword = await bcrypt.hash(password, 10);

    const user = new User();
    user.name = username;
    user.email = email;
    user.password = hashedPassword;

    await AppDataSource.getRepository(User).save(user);

    res.status(201).json({
      message: "Sikeres regisztr√°ci√≥!",
      user: { name: user.name, email: user.email },
      token: generateToken(user)
    });

  } catch (error) {
    console.error("Hiba a regisztr√°ci√≥ sor√°n:", error);
    res.status(500).json({ message: "Hiba t√∂rt√©nt a regisztr√°ci√≥ sor√°n", error });
  }
});

// üìå Bejelentkez√©s
router.post("/login", async (req: any, res: any) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: "Hi√°nyz√≥ adatok! (email, password sz√ºks√©ges)" });
    }

    const user = await AppDataSource.getRepository(User).findOne({ where: { email } });
    if (!user) {
      return res.status(400).json({ message: "Felhaszn√°l√≥ nem tal√°lhat√≥!" });
    }
 
    // Correct password comparison
    const isPasswordValid = await bcrypt.compare(password, user.password);

    if (!isPasswordValid) {
      return res.status(400).json({ message: "Hib√°s jelsz√≥!" });
    }

    res.status(200).json({
      message: "Sikeres bejelentkez√©s!",
      token: generateToken(user)
    });

  } catch (error) {
    console.error("Hiba a bejelentkez√©s sor√°n:", error);
    res.status(500).json({ message: "Hiba t√∂rt√©nt a bejelentkez√©s sor√°n", error });
  }
});

// üìå Felhaszn√°l√≥k kilist√°z√°sa (csak adminoknak)
router.get('/', tokencheck, isAdmin, async (_req: any, res: any) => {
  try {
    const users = await AppDataSource.getRepository(User).find({
      select: ["id", "name", "email", "role"], // V√°laszd ki, mely mez≈ëket szeretn√©l visszakapni
    });
 
    res.status(200).json({ users });
  } catch (error) {
    console.error("Hiba a felhaszn√°l√≥k kilist√°z√°sa sor√°n:", error);
    res.status(500).json({ message: "Hiba t√∂rt√©nt a felhaszn√°l√≥k lek√©r√©sekor.", error });
  }
});


// üìå Felhaszn√°l√≥i el≈ëfizet√©s (egy domain per user, csak bejelentkezett felhaszn√°l√≥knak)
router.post("/subscribe", tokencheck, async (req: any, res: any) => {
  try {
    const { packageId } = req.body;

    if (!packageId) {
      return res.status(400).json({ message: "Hi√°nyz√≥ adat! (packageId sz√ºks√©ges)" });
    }

    // üîπ Ellen≈ërizz√ºk, hogy a bejelentkezett felhaszn√°l√≥ l√©tezik-e
    const user = await AppDataSource.getRepository(User).findOne({ where: { id: req.user?.userId } });
    if (!user) {
      return res.status(404).json({ message: "Felhaszn√°l√≥ nem tal√°lhat√≥!" });
    }

    // üîπ Ellen≈ërizz√ºk, hogy a felhaszn√°l√≥nak m√°r van-e domainje (t√∂bb domain nem enged√©lyezett)
    const existingSubscription = await AppDataSource.getRepository(Subscription).findOne({ where: { user: user } });
    if (existingSubscription) {
      return res.status(400).json({ message: "M√°r van el≈ëfizet√©sed!" });
    }

    // üîπ A domain n√©v a felhaszn√°l√≥ nev√©b≈ël gener√°l√≥dik
    const domain = user.name.trim().toLowerCase().replace(/\s+/g, '').replace(/\W/g, '');

    // üîπ Csomag ellen≈ërz√©se
    const packageData = await AppDataSource.getRepository(Package).findOne({ where: { id: packageId } });
    if (!packageData) {
      return res.status(404).json({ message: "T√°rhelycsomag nem tal√°lhat√≥!" });
    }

    // üîπ √öj adatb√°zis l√©trehoz√°sa
    const rawPassword = generatePassword();
    const hashedPassword = await bcrypt.hash(rawPassword, 10);  
    const databaseName = `13a_${domain}`;
    const mysqlUser = `13a_${domain}`;
    const mysqlHost = "localhost";

    // üîπ √öj el≈ëfizet√©s l√©trehoz√°sa
    const subscription = new Subscription();
    subscription.user = user;
    subscription.package = packageData;
    subscription.date = new Date();
    subscription.domain = domain;

    await AppDataSource.getRepository(Subscription).save(subscription);

    // üîπ Adatb√°zis √©s felhaszn√°l√≥ l√©trehoz√°sa MySQL-ben
    const connection = await db.getConnection();
    try {
      await connection.query(`CREATE DATABASE \`${databaseName}\`;`);
      await connection.query(`CREATE USER '${mysqlUser}'@'${mysqlHost}' IDENTIFIED BY '${rawPassword}';`);
      await connection.query(`GRANT ALL PRIVILEGES ON \`${databaseName}\`.* TO '${mysqlUser}'@'${mysqlHost}';`);
      await connection.query(`FLUSH PRIVILEGES;`);
    } finally {
      connection.release();
    }

    // üîπ E-mail k√ºld√©se a felhaszn√°l√≥nak
    ejs.renderFile("views/subscription-email.ejs", { user, mysqlUser, rawPassword, databaseName, domain, mysqlHost }, async (err, html) => {
      if (err) {
        console.error("E-mail sablon renderel√©si hiba:", err);
        return res.status(500).json({ message: "Hiba t√∂rt√©nt az e-mail sablon renderel√©sekor", error: err });
      }

      const mailOptions = {
        from: `"T√°rhelyszolg√°ltat√≥" <${process.env.SMTP_USER}>`,
        to: user.email,
        subject: "El≈ëfizet√©s visszaigazol√°sa",
        html: html,
      };

      try {
        await transporter.sendMail(mailOptions);
        console.log("E-mail sikeresen elk√ºldve");
        res.status(201).json({ message: "El≈ëfizet√©s sikeres!", domain });
      } catch (error) {
        console.error("E-mail k√ºld√©si hiba:", error);
        res.status(500).json({ message: "Hiba t√∂rt√©nt az e-mail k√ºld√©sekor", error });
      }
    });

  } catch (error) {
    console.error("Hiba az el≈ëfizet√©s sor√°n:", error);
    res.status(500).json({ message: "Hiba t√∂rt√©nt az el≈ëfizet√©s sor√°n", error });
  }
});

export default router;
export { tokencheck, generateToken };
